/*
 * ECC.c
 *
 *  Created on: 10 feb. 2017
 *      Author: Casper
 */


#include "ECC.h"
#define MOD(x, p) (((x)%(p)) < 0 ? ((x)%(p) +(p)) : ((x)%(p)))


int ipow(int base, int exp, int m)
{
   int i, result = 1;

   for(i=0 ; i < exp ; i++)
   {
       result = MOD(result*base, m);
   }

    return result;

}

int gcdExtended(int a, int b, int *x, int *y)
/*source: http://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/*/
{
    if (a == 0)
    {
        *x = 0, *y = 1;
        return b;
    }
    int x1, y1;
    int gcd = gcdExtended(b%a, a, &x1, &y1);
    *x = y1 - (b/a) * x1;
    *y = x1;
    return gcd;
}

int ModInv(int a, int m)                            /*source (edited): http://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/*/
{

    int x, y;
    int g = gcdExtended(MOD(a, m), m, &x, &y);
    if (g != 1)
    {
        printf("Inverse of %d doesn't exist\n", a);
        return 0;
    }
    else
    {
        return MOD(x, m);
    }
}
int* ECC_addition(int P1[], int P2[])
{
    int m;
    static int P3[2];

    if (P1[2] == 1)                                                                                         /*case one*/
    {
        /*printf("case one\n");*/
        P3[0] = P2[0];
        P3[1] = P2[1];
        P3[2] = P2[2];

    }
    else if(P2[2] == 1)
    {
        /*printf("case one\n");*/
        P3[0] = P1[0];
        P3[1] = P1[1];
        P3[2] = P1[2];
    }
    else if (P1[0] == P2[0] && (P1[1] != P2[1] || (P1[1] == 0 && P2[1] == 0)))                              /*case two*/
    {

        /*printf("case two\n");*/
        P3[0]=0;
        P3[1]=0;
        P3[2]=1;

    }
    else                                                                                                    /* case three*/
    {
        /*printf("case three\n");*/
        if (*P1 == *P2)
        {
        m = (3 * param[0] * ipow(P1[0], 2, param[4]) + 2 * param[1] * P1[0] + param[2]) * ModInv(2, param[4]) * ModInv(P1[1], param[4]);
        }
        else
        {
        m = (P2[1] -P1[1]) * ModInv((P2[0]-P1[0]), param[4]);
        }
        m  = MOD(m, param[4]);
        /*printf("m= %d\n", m);*/


        P3[0] = - P1[0] - P2[0] - param[1] * ModInv(param[0], param[4]) + ipow(m,2, param[4]) * ModInv(param[0], param[4]);
        P3[0]  = MOD(P3[0], param[4]);

        P3[1] = - P1[1] + m * (P1[0] - P3[0]);
        P3[1]  = MOD(P3[1], param[4]);
        P3[2] = 0;

        }
    return P3;
}

int* ECC_multiplication(int P[], int n)
{
    int* q;
    int Q[3];
    Q[0] = P[0];
    Q[1] = P[1];
    Q[2] = 0;
    printf("Start: (%d, %d, %d)\n", Q[0], Q[1], Q[2]);
    while(n > 1)
    {
        printf("Adding P(%d, %d) and Q(%d, %d): ", P[0], P[1], Q[0], Q[1]);
        q = ECC_addition(P, Q);
        Q[0] = *q;
        Q[1] = *(q+1);
        Q[2] = *(q+2);
        printf("(%d, %d, %d)\n", Q[0], Q[1], Q[2]);
        if (onCurve(Q)!=1 && Q[2]!=1) printf("Calculated point not on curve!\n");
        --n;
    }
    return Q;
}

int main_ecc(int param[], int start[], int privateKey)
{
    int *K;

    K = ECC_multiplication(start, privateKey);

    return K;
}
